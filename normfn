#!/usr/bin/env python3

import argparse
import calendar
import datetime
import logging
import os
import os.path
import re
import shlex
import shutil
import sys
import textwrap
from collections.abc import Iterable, Sequence
from contextlib import suppress
from dataclasses import dataclass
from io import TextIOBase
from pathlib import Path
from typing import Literal, NoReturn, TypeVar, override

if not sys.version_info >= (3, 12):
    msg = "Needs at least Python 3.12"  # pyright: ignore[reportUnreachable]
    raise ValueError(msg)

BASENAME_EXCLUDE_PATTERNS = frozenset([r"\..*", "Icon\r", r".*\.lo?ck"])

EFFECTIVE_SEP = r"\\" if os.sep == "\\" else os.sep

FULLNAME_EXCLUDE_PATTERNS = frozenset(
    [
        r".*\.git" + EFFECTIVE_SEP + r".*",
        r".*\.svn" + EFFECTIVE_SEP + r".*",
        r".*\.hg" + EFFECTIVE_SEP + r".*",
        r".*\.bzr" + EFFECTIVE_SEP + r".*",
    ]
)

YEAR = ""


@dataclass
class Args:
    verbose: int
    help: bool
    dry_run: bool
    interactive: bool
    all: bool
    force: bool
    add_time: bool
    discard_existing_name: bool
    recursive: bool
    max_years_ahead: int
    max_years_behind: int
    undo_log_file: str | None
    no_undo_log_file: bool
    time_option: Literal["now", "earliest", "latest"]
    filenames: list[str]


def parse_arguments(argv: list[str]) -> Args:
    class ArgumentParser(argparse.ArgumentParser):
        @override
        def error(self, message: str) -> NoReturn:
            parser.print_help()
            raise FatalError(message)

    parser = ArgumentParser(
        description=(
            "Normalizes filenames by prefixing a date to them. "
            "See https://github.com/andrewferrier/normfn for more information."
        ),
        add_help=False,
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Add debugging output. Using this twice makes it doubly verbose.",
    )

    parser.add_argument(
        "-h",
        "--help",
        action="store_true",
        help="Show help information for normfn.",
    )

    parser.add_argument(
        "-n",
        "--dry-run",
        action="store_true",
        dest="dry_run",
        help=(
            "Don't actually make any changes, just show them. Forces "
            "a single level of verbosity (-v)."
        ),
    )

    parser.add_argument(
        "-i",
        "--interactive",
        action="store_true",
        dest="interactive",
        help="Ask about each change before it is done.",
    )

    parser.add_argument(
        "-a",
        "--all",
        action="store_true",
        dest="all",
        help="Affect all files, including those in default exclude lists.",
    )

    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        dest="force",
        help=(
            "Overwrite target files if they already exist "
            "(USE WITH CAUTION, consider using --dry-run first)."
        ),
    )

    parser.add_argument(
        "-t",
        "--add-time",
        action="store_true",
        dest="add_time",
        help="If a time is not found in the filename, add one.",
    )

    parser.add_argument(
        "-d",
        "--discard-existing-name",
        action="store_true",
        dest="discard_existing_name",
        help="Discard existing name and just use the date/time prefix.",
    )

    parser.add_argument(
        "-r",
        "--recursive",
        action="store_true",
        dest="recursive",
        default=False,
        help=(
            "Recurse into directories specified on the command line. The default is "
            "not to do this, and simply look at the name of the directory itself."
        ),
    )

    parser.add_argument(
        "--max-years-ahead",
        type=int,
        dest="max_years_ahead",
        default=5,
        help=(
            "Consider years further ahead from now than this not "
            "to be valid years. Defaults to 5."
        ),
    )

    parser.add_argument(
        "--max-years-behind",
        type=int,
        dest="max_years_behind",
        default=30,
        help=(
            "Consider years further behind from now than this not "
            "to be valid years. Defaults to 30."
        ),
    )

    log_option = parser.add_mutually_exclusive_group()

    log_option.add_argument(
        "--undo-log-file",
        type=str,
        dest="undo_log_file",
        help=(
            "The name of the shell script to log "
            "'undo commands' for normfn; see the "
            "instructions in the file to use. "
            f"Defaults to {get_default_log_file()}"
        ),
    )

    log_option.add_argument(
        "--no-undo-log-file",
        dest="no_undo_log_file",
        action="store_true",
        help="Inverse of --undo-log-file; don't store undo commands.",
    )

    time_option = parser.add_mutually_exclusive_group()

    time_option.add_argument(
        "--now",
        action="store_const",
        dest="time_option",
        const="now",
        help=(
            "Use date and time now as the default "
            "file prefix for filenames without them."
        ),
    )

    time_option.add_argument(
        "--latest",
        "--newest",
        action="store_const",
        dest="time_option",
        const="latest",
        help=(
            "Use the latest of ctime and mtime "
            "to define a file prefix for files without them. "
            "Note: ctime is *not* "
            "file creation on Linux/OS X; see "
            "http://lwn.net/Articles/397442/."
        ),
    )

    time_option.add_argument(
        "--earliest",
        "--oldest",
        action="store_const",
        dest="time_option",
        const="earliest",
        help=(
            "Use earliest of ctime and mtime "
            "to define a file prefix for files without them. "
            "This is the default."
        ),
    )

    parser.set_defaults(
        time_option="earliest",
        undo_log_file=get_default_log_file(),
    )

    class FilenamesAction(argparse.Action):
        @override
        def __call__(  # pyright: ignore[reportIncompatibleMethodOverride]
            self,
            parser: argparse.ArgumentParser,
            args: argparse.Namespace,
            values: Sequence[str],
            _: str | None = None,
        ) -> None:
            args.filenames = list(values)
            args_help: bool = args.help  # pyright: ignore[reportAny]
            if not args_help and len(values) < 1:
                parser.error("You must specify some file or directory names.")

    parser.add_argument(
        "filenames",
        metavar="filename",
        nargs="*",
        help="Filenames",
        action=FilenamesAction,
    )

    args_ns = parser.parse_args(argv[1:])

    args = Args(**vars(args_ns))  # pyright: ignore[reportAny]

    if args.help:
        parser.print_help()
        sys.exit(0)

    return args


def main(argv: list[str], syserr_handler: logging.StreamHandler[TextIOBase]) -> None:
    logger = logging.getLogger("normfn")

    args = parse_arguments(argv)

    if args.dry_run:
        args.verbose = max(args.verbose, 1)

    if syserr_handler:
        if args.verbose > 1:
            syserr_handler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            syserr_handler.setLevel(logging.INFO)
        else:
            syserr_handler.setLevel(logging.WARNING)

    logger.debug(f"Arguments are: {args}")

    if args.no_undo_log_file:
        args.undo_log_file = None

    global YEAR

    year_now = datetime.datetime.now(tz=datetime.UTC).year
    year_list = [
        str(year)
        for year in range(
            year_now - args.max_years_behind, year_now + args.max_years_ahead
        )
    ]
    logger.debug(f"Valid years are: {year_list}")
    YEAR = r"(" + "|".join(year_list) + r")"

    with suppress(QuitError):
        for arg_filename in args.filenames:
            filename = os.path.abspath(arg_filename)
            if not os.path.exists(filename):
                raise FatalError(
                    filename + " specified on the command line does not exist."
                )

            if os.path.isdir(filename) and args.recursive:
                new_filename = process_filename(filename, args)
                walk_tree(new_filename, args)
            else:
                process_filename(filename, args)


def get_default_log_file() -> Path:
    home: Path = Path("~").expanduser()
    xdg_state_home: Path = Path(
        os.environ.get("XDG_STATE_HOME") or home / ".local" / "state"
    )
    return xdg_state_home / "normfn-undo.log.sh"


def walk_tree(dirname: str, args: Args) -> None:
    logger = logging.getLogger("normfn")

    logger.debug(f"Walking directory tree {dirname}")
    dirlist = sorted(os.listdir(dirname))

    for entry in dirlist:
        entry_full = os.path.join(dirname, entry)

        entry_full = process_filename(entry_full, args)
        if os.path.isdir(entry_full):
            walk_tree(entry_full, args)


def create_regex() -> str:
    month_names_only = (
        "|".join(map(insensitiveize, calendar.month_name[1:13]))
        + "|"
        + "|".join(map(insensitiveize, calendar.month_abbr[1:13]))
    )
    month = r"(0[1-9]|1[012]|[1-9](?!\d)|" + month_names_only + ")"
    day = r"(0[1-9]|[12]\d|3[01]|[1-9](?!\d))"
    hour = r"([01]\d|2[0123])"
    minute = second = r"[012345]\d"

    date_separator = r"[-_.\s]?"
    ymd_separator_first = r"(?P<ymdsep>" + date_separator + r")"
    ymd_separator_following = r"(?P=ymdsep)"
    dmy_separator_first = r"(?P<dmysep>" + date_separator + r")"
    dmy_separator_following = r"(?P=dmysep)"
    my_separator = date_separator
    hms_separator_first = r"(?P<hmssep>[-_.\s]?)"
    hms_separator_following = r"(?P=hmssep)"
    date_time_separator = r"([-_T\s]|\sat\s|,\s)"

    return (
        r"^(?P<prefix>.*?)[-_]?"
        + r"("
        +
        # Y-M-D style
        r"(?P<year1>"
        + YEAR
        + r")"
        + ymd_separator_first
        + r"(?P<month1>"
        + month
        + r")"
        + r"("
        + ymd_separator_following
        + r"(?P<day1>"
        + day
        + r"))?"
        + r"|"
        +
        # D-M-Y style
        r"(?P<day2>"
        + day
        + r")"
        + dmy_separator_first
        + r"(?P<month2>"
        + month
        + r")"
        + dmy_separator_following
        + r"(?P<year2>"
        + YEAR
        + r")"
        + r"|"
        +
        # M-Y style, with months in name only
        r"(?P<month3>"
        + month_names_only
        + r")"
        + my_separator
        + r"(?P<year3>"
        + YEAR
        + r")"
        + r")"
        + r"("
        + date_time_separator
        + r"(?P<hour>"
        + hour
        + r")"
        + (r"(" + hms_separator_first + r"(?P<minute>" + minute + r")")
        + (r"(" + hms_separator_following + r"(?P<second>" + second + r"))?)?)?")
        + r"(?P<suffix>.*)$"
    )


def datetime_prefix(args: Args, non_extension: str, filename: str) -> str:
    logger = logging.getLogger("normfn")

    T = TypeVar("T")

    def first_not_none(values: Iterable[T | None]) -> T | None:
        for item in values:
            if item is not None:
                return item

        return None

    def replacement(matchobj: re.Match[str]) -> str:
        logger.debug(f"replacement() called, matchobj = {matchobj}")

        year = str(
            first_not_none(
                [
                    matchobj.group("year1"),
                    matchobj.group("year2"),
                    matchobj.group("year3"),
                ]
            )
        )
        month = str(
            first_not_none(
                [
                    matchobj.group("month1"),
                    matchobj.group("month2"),
                    matchobj.group("month3"),
                ]
            )
        )
        day = first_not_none([matchobj.group("day1"), matchobj.group("day2")])

        if not month.isdigit():
            try:
                month_digit = list(map(str.lower, calendar.month_abbr)).index(
                    month.lower()
                )
            except ValueError:
                month_digit = list(map(str.lower, calendar.month_name)).index(
                    month.lower()
                )

            month = str(month_digit)

        if len(month) == 1:
            month = "0" + month

        if day is not None and len(day) == 1:
            day = "0" + day

        replace_value = (
            year
            + "-"
            + month
            + (("-" + day) if day is not None else "")
            + (
                ("T" + matchobj.group("hour"))
                if matchobj.group("hour") is not None
                else ""
            )
            + (
                ("-" + matchobj.group("minute"))
                if matchobj.group("minute") is not None
                else ""
            )
            + (
                ("-" + matchobj.group("second"))
                if matchobj.group("second") is not None
                else ""
            )
        )

        if not args.discard_existing_name:
            replace_value = replace_value + (
                (
                    ("-" + matchobj.group("prefix"))
                    if matchobj.group("prefix") != ""
                    else ""
                )
                + (matchobj.group("suffix") if matchobj.group("suffix") != "" else "")
            )

        logger.debug(f"replacement() returned: {replace_value}")
        return replace_value

    regex = create_regex()

    logger.debug(f"Complete regex used against {non_extension}: {regex}")

    (newname, number_of_subs) = re.subn(regex, replacement, non_extension)

    if number_of_subs > 1:
        msg = "Number of subs should be less than 1"
        raise ValueError(msg)

    if number_of_subs == 0:
        logger.debug("Didn't find date or time")

        timetouse = get_timetouse(args.time_option, Path(filename))

        newname_with_dash_if_needed = (
            ("-" + newname) if not args.discard_existing_name else ""
        )

        if args.add_time:
            newname = (
                timetouse.strftime("%Y-%m-%dT%H-%M-%S") + newname_with_dash_if_needed
            )
        else:
            newname = timetouse.strftime("%Y-%m-%d") + newname_with_dash_if_needed

    return newname


def process_filename(filename: str, args: Args) -> str:
    logger = logging.getLogger("normfn")

    logger.debug(f"Processing filename {filename}")
    basename = os.path.basename(filename)

    if not args.all:
        (exclude, why) = should_exclude(filename, basename)
        if exclude:
            logger.info(f"Skipping {filename.strip()} as it matches pattern {why}")
            return filename

    (non_extension, extension) = os.path.splitext(basename)

    non_extension = datetime_prefix(args, non_extension, filename)

    newname = non_extension.strip() + extension

    original_filename = filename
    filename = os.path.join(os.path.dirname(original_filename), newname)
    logger.debug(f"Potential new filename for {original_filename} is {filename}")

    if filename == original_filename:
        logger.debug("New filename would be identical, skipping.")
        return original_filename

    force: bool = args.force

    validate_move(force, Path(original_filename), Path(filename))

    move_it = True

    if args.interactive:
        move_it = ask_yes_no(
            f"Move {original_filename.strip()} to .../{newname} [y/n/e/q]?"
        )
        if move_it == b"e":
            new_filename = rlinput("What new filename? ", newname)
            new_filename = os.path.join(
                os.path.dirname(original_filename), new_filename
            )
            validate_move(force, Path(original_filename), Path(new_filename))
            filename = new_filename
        else:
            move_it = move_it == b"y"

    if move_it:
        if not args.dry_run:
            undo_log_file = (
                Path(args.undo_log_file) if args.undo_log_file is not None else None
            )

            shiftfile(undo_log_file, original_filename, filename)
            return filename

        logger.info(f"Not moving {original_filename.strip()} to {filename}; dry run.")
        return original_filename

    logger.info(f"Not moving {original_filename.strip()}")
    return original_filename


def should_exclude(filename: str, basename: str) -> tuple[bool, str]:
    match = False
    exclude_pattern = ""

    for exclude_pattern in BASENAME_EXCLUDE_PATTERNS:
        if re.fullmatch(exclude_pattern, basename):
            match = True
            break

    if not match:
        for exclude_pattern in FULLNAME_EXCLUDE_PATTERNS:
            if re.fullmatch(exclude_pattern, filename):
                match = True
                break

    return (match, exclude_pattern)


def get_timetouse(
    time_option: Literal["now", "earliest", "latest"], filename: Path
) -> datetime.datetime:
    ctime = datetime.datetime.fromtimestamp(filename.stat().st_ctime, tz=datetime.UTC)
    mtime = datetime.datetime.fromtimestamp(filename.stat().st_mtime, tz=datetime.UTC)

    if time_option == "now":
        timetouse = datetime.datetime.now(tz=datetime.UTC)
    elif time_option == "earliest":
        timetouse = min(ctime, mtime)
    else:
        timetouse = max(ctime, mtime)

    return timetouse


def validate_move(force: bool, original_filename: Path, filename: Path) -> None:
    if filename.exists() and not force:
        raise FatalError(
            f"Want to move {original_filename} to "
            + f"{filename}, but it already exists."
        )


def rlinput(prompt: str, prefill: str = "") -> str:
    if os.name == "nt":
        return input(prompt)
    import readline  # noqa: PLC0415

    readline.set_startup_hook(lambda: readline.insert_text(prefill))
    try:
        return input(prompt)
    finally:
        readline.set_startup_hook()


def shiftfile(undo_log_file: Path | None, source: str, target: str) -> None:
    logger = logging.getLogger("normfn")

    source = os.path.abspath(source)
    target = os.path.abspath(target)

    dt_now = datetime.datetime.now(tz=datetime.UTC).strftime("%Y-%m-%dT%H-%M-%S")

    try:
        shutil.move(source, target)
    except PermissionError as permission_error:
        filename: str = permission_error.filename  # pyright: ignore[reportAny]
        if filename == source:
            msg = f"Permission denied on source: {filename}"
            raise FatalError(msg) from permission_error

        if filename == target:
            msg = f"Permission denied on target: {filename}"
            raise FatalError(msg) from permission_error

        raise

    if undo_log_file:
        check_undo_log_file_header(undo_log_file)
        with undo_log_file.open("a", encoding="utf-8") as log_file:
            _ = log_file.write(f"# {dt_now}: moving {source} to {target}\n")
            _ = log_file.write(f"mv {shlex.quote(target)} {shlex.quote(source)}\n")
    logger.info(f"{source} moved to {target}")


def check_undo_log_file_header(undo_log_file: Path) -> None:
    if not undo_log_file.exists():
        with undo_log_file.open("w") as log_file:
            wrapper = textwrap.TextWrapper(initial_indent="# ", subsequent_indent="# ")
            _ = log_file.write("#!/bin/sh\n")
            _ = log_file.write(
                wrapper.fill(
                    "File generated by normfn "
                    + "(see http://www.github.com/andrewferrier/normfn). This file is "
                    + "utf-8 encoded)"
                )
                + "\n"
            )
            _ = log_file.write("#\n")
            _ = log_file.write(
                wrapper.fill(
                    "This file contains shell commands which can be "
                    + "run to invert (undo) the effects of "
                    + "running normfn. They must be run in *reverse order*. "
                    + f"You can achieve this by running `tac {undo_log_file}"
                    + " | sh`. If you wish, you can edit "
                    + "the file first to control which actions are undone."
                )
                + "\n"
            )
            _ = log_file.write("#\n")
            _ = log_file.write(
                wrapper.fill(
                    "(Specific note for MacOS: tac may not be installed. "
                    + "You can install gtac, the "
                    + "equivalent command, using `brew install coreutils`. "
                    + "You will need Homebrew - "
                    + "http://brew.sh/ - installed)"
                )
                + "\n"
            )
            _ = log_file.write("\n")


def ask_yes_no(prompt: str) -> bytes:
    while True:
        print(prompt, end="", flush=True)  # noqa: T201
        try:
            key = readchar().lower()
        except KeyboardInterrupt as ki:
            raise QuitError from ki
        print(str(key, "utf-8"))  # noqa: T201
        if key in [b"y", b"n", b"e"]:
            return key
        if key == b"q":
            raise QuitError


def readchar() -> bytes:
    if os.name == "nt":
        import msvcrt  # noqa: PLC0415

        return msvcrt.getch()

    import termios  # noqa: PLC0415
    import tty  # noqa: PLC0415

    try:
        old_settings = termios.tcgetattr(sys.stdin)
        _ = tty.setcbreak(sys.stdin.fileno())
        try:
            return os.read(sys.stdin.fileno(), 1)
        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
    except termios.error:
        return os.read(sys.stdin.fileno(), 1)


def insensitiveize(string: str) -> str:
    return "".join(("[" + char.lower() + char.upper() + "]") for char in string)


class FatalError(Exception):
    def __init__(self, value: str) -> None:
        Exception.__init__(self, value)
        self.value: str = value

    @override
    def __str__(self) -> str:
        return repr(self.value)


class QuitError(Exception):
    pass


if __name__ == "__main__":
    logger_setup = logging.getLogger("normfn")
    logger_setup.propagate = False
    logger_setup.setLevel(logging.DEBUG)

    syserrhandler = logging.StreamHandler(stream=sys.stderr)
    syserrhandler.setLevel(logging.WARNING)
    syserrformatter = logging.Formatter("%(levelname)s: %(message)s")
    syserrhandler.setFormatter(syserrformatter)
    logger_setup.addHandler(syserrhandler)

    try:
        main(sys.argv, syserrhandler)
    except FatalError as error:
        logger_setup.exception(error.value)
        sys.exit(2)
